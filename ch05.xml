<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch05_sql_inj">
  <title>SQL Injection</title>
  <para><indexterm><primary>SQL Injection</primary></indexterm>SQL Injection is the scourge of database programming. The vulnerability is a server-side injection attack and occurs when the attacker inserts malicious code into SQL query. OWASP and ESAPI do not supply controls for SQL Injections. Rather, you use the controls provided by the platform you are working on.</para>
  <section id="sql_inj_documentation" xreflabel="PreparedStatement Documentation">
    <title>Documentation</title>
    <para><indexterm><primary>SQL Injection</primary><secondary>Documentation</secondary></indexterm><indexterm><primary>SQL Injection</primary><secondary>PreparedStatement</secondary></indexterm>Documentation for Java <systemitem>PreparedStatement</systemitem> class is located at <ulink url="https://docs.oracle.com/javase/8/docs/api/index.html?java/sql/PreparedStatement.html">Interface PreparedStatement</ulink>.</para>
    <para><indexterm><primary>SQL Injection</primary><secondary>CallableStatement</secondary></indexterm>Documentation for Java <systemitem>CallableStatement</systemitem> class is located at <ulink url="https://docs.oracle.com/javase/8/docs/api/java/sql/CallableStatement.html">Interface CallableStatement</ulink>.</para>
    <para><indexterm><primary>SQL Injection</primary><secondary>ParameterizedQuery</secondary></indexterm>Documentation for .Net <systemitem>SqlCommand</systemitem> class is located at <ulink url="https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand">SqlCommand Class</ulink>.</para>
    <para>OWASP provides a SQL Injection cheat sheet at <ulink url="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">SQL Injection Prevention Cheat Sheet</ulink>.</para>
  </section>
  <section id="sql_inj_strategy">
    <title>Strategy</title>
    <para><indexterm><primary>SQL Injection</primary><secondary>Strategy</secondary></indexterm>The primary defense against SQL Injections are Prepared Statements or Parameterized Queries. Prepared Statements and Parameterized Queries bind user data in bind variables. Once bound, the underlying database engine will not unintentionally execute the user supplied data as code.</para>
    <para>A secondary defense against SQL Injections is encoding dangerous characters so the attacker supplied data is not interpreted as code by the underlying database engine. Encoding is an anti-pattern and should not be used. Instead, you should bind the user supplied data using Prepared Statements or Parameterized Queries.</para>
    <para>Encoding translates dangerous characters into a benign representations for storage in a database. The table below shows safe ways to encode dangerous characters.</para>
    <table frame="all">
      <title>Safe Encoding of Dangerous SQL Characters</title>
      <tgroup cols="3" align="center" colsep="1" rowsep="1">
        <colspec colnum="1" colname="character" colwidth="1*"/>
        <colspec colnum="2" colname="encoding" colwidth="1*"/>
        <colspec colnum="3" colname="comment" colwidth="1*"/>
        <thead>
          <row>
            <entry>Character</entry>
            <entry>Encoding</entry>
            <entry>Comment</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>' (single quote)</entry>
            <entry>''</entry>
            <entry>Single quote espaced with a single quote</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  <section id="sql_inj_chinook_db" xreflabel="Chinook Database">
    <title>Chinook Database</title>
    <para><indexterm><primary>Chinook</primary></indexterm><ulink url="https://github.com/lerocha/chinook-database">The Chinook database</ulink> is a sample database available for SQL Server, Oracle, MySQL, and SQLite. Chinook is the free/open source software equivalent to Microsoft's Northwind database.</para>
    <para>The Chinook database is used in the samples for this chapter. A partial output of Chinook's table schema is reproduced below. Notice the <systemitem>Customer</systemitem> and <systemitem>Employee</systemitem> table schemas are similar. The similarity will be abused later under <xref linkend="sql_inj_dynamic_binding"/>.</para>
    <example id="sql_inj_chinook_schema" xreflabel="Chinook Database Schema">
      <title>Chinook Database Schema</title>
      <programlisting><?code-font-size 75% ?>$ sqlite3 Chinook.sqlite
sqlite&gt; .tables
Album          Employee       InvoiceLine    PlaylistTrack
Artist         Genre          MediaType      Track
Customer       Invoice        Playlist

sqlite&gt; .schema Album
CREATE TABLE [Album]
(
    [AlbumId] INTEGER  NOT NULL,
    [Title] NVARCHAR(160)  NOT NULL,
    [ArtistId] INTEGER  NOT NULL,
    CONSTRAINT [PK_Album] PRIMARY KEY  ([AlbumId]),
    FOREIGN KEY ([ArtistId]) REFERENCES [Artist] ([ArtistId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_AlbumArtistId] ON [Album] ([ArtistId]);

sqlite&gt; .schema Artist
CREATE TABLE [Artist]
(
    [ArtistId] INTEGER  NOT NULL,
    [Name] NVARCHAR(120),
    CONSTRAINT [PK_Artist] PRIMARY KEY  ([ArtistId])
);

sqlite&gt; .schema Customer
CREATE TABLE [Customer]
(
    [CustomerId] INTEGER  NOT NULL,
    [FirstName] NVARCHAR(40)  NOT NULL,
    [LastName] NVARCHAR(20)  NOT NULL,
    [Company] NVARCHAR(80),
    [Address] NVARCHAR(70),
    [City] NVARCHAR(40),
    [State] NVARCHAR(40),
    [Country] NVARCHAR(40),
    [PostalCode] NVARCHAR(10),
    [Phone] NVARCHAR(24),
    [Fax] NVARCHAR(24),
    [Email] NVARCHAR(60)  NOT NULL,
    [SupportRepId] INTEGER,
    CONSTRAINT [PK_Customer] PRIMARY KEY  ([CustomerId]),
    FOREIGN KEY ([SupportRepId]) REFERENCES [Employee] ([EmployeeId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_CustomerSupportRepId] ON [Customer] ([SupportRepId]);

sqlite&gt; .schema Employee
CREATE TABLE [Employee]
(
    [EmployeeId] INTEGER  NOT NULL,
    [LastName] NVARCHAR(20)  NOT NULL,
    [FirstName] NVARCHAR(20)  NOT NULL,
    [Title] NVARCHAR(30),
    [ReportsTo] INTEGER,
    [BirthDate] DATETIME,
    [HireDate] DATETIME,
    [Address] NVARCHAR(70),
    [City] NVARCHAR(40),
    [State] NVARCHAR(40),
    [Country] NVARCHAR(40),
    [PostalCode] NVARCHAR(10),
    [Phone] NVARCHAR(24),
    [Fax] NVARCHAR(24),
    [Email] NVARCHAR(60),
    CONSTRAINT [PK_Employee] PRIMARY KEY  ([EmployeeId]),
    FOREIGN KEY ([ReportsTo]) REFERENCES [Employee] ([EmployeeId])
                ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE INDEX [IFK_EmployeeReportsTo] ON [Employee] ([ReportsTo]);</programlisting>
    </example>
  </section>
  <section id="sql_inj_vulnerable_query" xreflabel="Vulnerable Query">
    <title>Vulnerable Query</title>
    <para>An example of a vulnerable query is shown below. The code is vulnerable due to simple concatenation without any controls on the user supplied input.</para>
    <example id="sql_inj_ex_vulnerable_query" xreflabel="Vulnerable Query, Pwned">
      <title>Vulnerable Query, Pwned</title>
      <programlisting><?code-font-size 75% ?>String lastName = request.getParameter("lastName");

String query = "SELECT FirstName,LastName FROM Customer WHERE LastName = " + lastName;
Statement statement = connection.createStatement(...);

ResultSet results = statement.executeQuery(query);</programlisting>
    </example>
  </section>
  <section id="sql_inj_prepared_statement" xreflabel="Prepared Statements">
    <title>Prepared Statements</title>
    <para><indexterm><primary>SQL Injection</primary><secondary>PreparedStatement</secondary></indexterm><indexterm><primary>PreparedStatement</primary></indexterm>Prepared Statements are used in Java as the primary defense against SQL injections. A <systemitem>PreparedStatement</systemitem> is a precompiled SQL statement with placeholders for for user supplied or attacker controlled data. Java uses the question mark (<systemitem>?</systemitem>) as a placeholder for the data.</para>
    <para>An example of a Prepared Statement is shown below. The Prepared Statement is not vulnerable to a SQL Injection because the user supplied data is not interpreted as code.</para>
    <example id="sql_inj_ex_prepared_statement_java" xreflabel="Prepared Statement">
      <title>Prepared Statement, Java</title>
      <programlisting><?code-font-size 75% ?>String lastName = request.getParameter("lastName");
String query = "SELECT FirstName,LastName FROM Customer WHERE LastName = ?";

PreparedStatement command = connection.prepareStatement(query);
command.setString(1, lastName);

ResultSet results = command.executeQuery( );</programlisting>
    </example>
    <para>It is possible to use a Prepared Statement, and still be vulnerable to a SQL Injection attack. The example below shows an insecure query based on a Prepared Statement.</para>
    <example id="sql_inj_ex_prepared_statement_java_bad" xreflabel="Incorrect Prepared Statement">
      <title>Incorrect Prepared Statement, Java</title>
      <programlisting><?code-font-size 75% ?>String tableName = request.getParameter("tableName");
String lastName = request.getParameter("lastName");
String query = "SELECT FirstName,LastName FROM " + tableName + " WHERE LastName = ?";

PreparedStatement command = connection.prepareStatement(query);
command.setString(1, lastName);

ResultSet results = command.executeQuery( );</programlisting>
    </example>
    <para>The problem with <xref linkend="sql_inj_ex_prepared_statement_java_bad"/> is, <systemitem>tableName</systemitem> is not bound in the Prepared Statement. Rather, it is concatenated like in <xref linkend="sql_inj_ex_vulnerable_query"/>. In fact, the variable <systemitem>tableName</systemitem> cannot be bound because table names and column names cannot be bound. The problem is discussed in detail in <xref linkend="sql_inj_dynamic_binding"/>.</para>
  </section>
  <section id="sql_inj_callable_statement" xreflabel="Callable Statements">
    <title>Callable Statements</title>
    <para><indexterm><primary>SQL Injection</primary><secondary>CallableStatement</secondary></indexterm><indexterm><primary>CallableStatement</primary></indexterm>Callable Statements along with parameter binding are used to defend against SQL Injections in <indexterm><primary>SQL Injection</primary><secondary>Stored Procedure</secondary></indexterm><indexterm><primary>Stored Procedure</primary></indexterm>Stored Procedures. An example of a Callable Statement is shown below. The Callable Statements is not vulnerable to a SQL Injection because the user supplied data is not interpreted as code.</para>
    <example id="sql_inj_ex_callable_statement_java" xreflabel="Callable Statement">
      <title>Callable Statement, Java</title>
      <programlisting><?code-font-size 75% ?>String lastName = request.getParameter("lastName");

CallableStatement statement = connection.prepareCall("{call sp_getCustomerName(?, ?)}");
statement.setString(1, lastName);

statement.registerOutParameter(1, Types.NVARCHAR);
statement.registerOutParameter(2, Types.NVARCHAR);

ResultSet results = statement.executeQuery();</programlisting>
    </example>
    <para>The SQL code for <systemitem>sp_getCustomerName</systemitem> would look similar to below. The definitions for <systemitem>lastName</systemitem> and <systemitem>firstName</systemitem> are taken from <xref linkend="sql_inj_chinook_schema"/>.</para>
    <programlisting><?code-font-size 75% ?>CREATE PROCEDURE sp_getCustomerName(INOUT lastName NVARCHAR(20), \
                                    OUT  firstName NVARCHAR(40))
BEGIN
    SELECT LastName, FirstName
    INTO lastName, firstName
    FROM Customer
    WHERE LastName = lastName;
END</programlisting>
    <para>If you want to use a Callable Statement outside a Stored Procedure in Java, then you should use <xref linkend="sql_inj_prepared_statement"/> instead.</para>
  </section>
  <section id="sql_inj_parameterized_query" xreflabel="Parameterized Queries">
    <title>Parameterized Queries</title>
    <!-- https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand.parameters -->
    <para><indexterm><primary>SQL Injection</primary><secondary>ParameterizedQuery</secondary></indexterm><indexterm><primary>ParameterizedQuery</primary></indexterm>Parameterized Queries are used in .Net as the primary defense against SQL injections. A <systemitem>SqlCommand</systemitem> is a precompiled SQL statement with named parameters for attacker controlled data.</para>
    <para>An example of a Parameterized Query is shown below. The Microsoft .NET Framework Data Provider for SQL Server does not support the question mark (<systemitem>?</systemitem>) placeholder for passing parameters to a SQL Statement or a stored procedure called by a command of <systemitem>CommandType.Text</systemitem>. A named parameter must be used instead.</para>
    <example id="sql_inj_ex_parameterized_query_dotnet">
      <title>Parameterized Query, .Net</title>
      <programlisting><?code-font-size 75% ?>String lastName = request.getParameter("lastName");
String query = "SELECT FirstName,LastName FROM Customer WHERE LastName = @LNAME";

SqlCommand command = new SqlCommand(query, connection);
command.Parameters.Add("@LNAME", SqlDbType.Text);
command.Parameters["@LNAME"].Value = lastName;

ResultSet results = command.executeQuery( );</programlisting>
    </example>
  </section>
  <section id="sql_inj_encoding">
    <title>Encoding</title>
    <para>.</para>
  </section>
  <section id="sql_inj_dynamic_binding">
    <title>Dynamic Query</title>
    <para><indexterm><primary>SQL Injection</primary><secondary>Dynamic Query</secondary></indexterm><indexterm><primary>Dynamic Query</primary></indexterm>Dynamic queries refers to the technique of selecting table names and column names at runtime rather than using a static query declared at compile time. Dynamic queries usually select the table name or column name at runtime using concatenation to build the SQL query. The problem with dynamic queries is, you cannot bind a table name or column name in a Prepared Statement or Parameterized Query.</para>
    <para/>
    <para>Your primary defense in dynamic query is to avoid the technique in the first place.</para>
  </section>
</chapter>
